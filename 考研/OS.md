# OS
> 同步与异步
- 在微机原理中，有同步通信和异步通信
    - 同步通信 => 是一种比特同步通信技术，要求发收双方具有同频同相的同步时钟信号，只需在传送报文的最前面附加特定的同步字符，使发收双方建立同步，此后便在同步时钟的控制下逐位发送/接收。
    - 异步通信 => 异步通信是指通信中两个字符（8位）之间的时间间隔是不固定的，而在一个字符内各位的时间间隔是固定的。
- 在OS中
    - 同步按队列输出
    - 异步不按队列输出
## 1 OS introduction
### 1.1 OS 的目标和作用
- OS => 是管理计算机系统的全部硬件资源以及软件资源；控制程序运行；改善人机界面；为其它应用软件提供支持等，使计算机系统所有资源最大限度地发挥作用，为用户提供方便的、有效的、友善的服务界面。
- OS目标
    - 方便性 由汇编到高级语言 / shell
    - 有效性 提高系统资源的利用率和系统的吞吐量（单位时间内处理工作的能力）
    - 可扩展性 适应硬件发展 eg 微内核
    - 开放性 可移植性  or 可兼容
- OS作用
    - OS作为用户与硬件的接口 shell
    - OS作为计算机系统资源（CPU,memory,I/O,数据和程序）的管理者 
    - OS实现了对计算机资源的抽象 将物理接口汇编语言抽象为高级语言指令 如 read/write
- OS发展的动力
    - 提高计算机资源的利用率 有效性
    - 方便用户 方便性
    - 器件的更新 开放性
    - 计算机体系结构的发展
    - 新的应用需求
### 1.2 OS的发展过程
- 无OS 
    - 人工 打孔纸带
    - 脱机输入/输出（Off-Line I/O）I => 外围机加纸带将其转为磁带，高速加入内存 O => 内存到磁带，磁带由外围机到纸带
        - 减少CPU空闲 外围机写纸带
        - 提高I/O速度 从磁带取到内存
#### 有OS 
- 单道批处理的处理过程 simple batch processing system
    - （Off-Line I）多个作业加入，监控程序（monitor）将作业顺序放入内存，并将控制权给作业
    - 特点 
        - 独占性 一个作业独占内存和CPU
        - 一致性 输出按队列
        - ?
- 多道批处理的处理过程 multi programmed batch processing system
    - 在外存的作业队列多个进入内存，当 A I/O操作时的CPU空挡运行 B
    - 特点 
        - 共享性
        - 异步性 输出不按队列
        - 不可再现 不知用户交互时，运行那个程序 要输出A，可能输出了B
        - 系统吞吐量大 CPU I/O 内存同时工作 
- 分时系统 time sharing system
    - input 时多路卡和缓冲区
    - 轮转运行 split 一个时间片运行一个程序，下一个时间片运行下一个程序
    - 特点
        - 多路性
        - 独立性
        - 及时性
        - 交互性
        - 异步性
- 实时系统 real time system
    - 实时即及时，计算不但要正确，还要在规定时间完成
> 微机OS的发展 单用户单任务 / 单用户多任务/ 多用户多任务
### 1.3 OS的基本特性
#### 并发（concurrence）最基本
- 并行性 多事件同时间点发生
- 并发性 多事件同时间段发生
- 进程 能独立运行的并作为资源分配的基本单位
    - 为计算程序和I/O程序分别建立进程就可以，当 A I/O操作时的 CPU空挡运行 B
#### 共享sharing
- 时间和地点上共享 二人在同一地点同时看一本书
    - 互斥共享 A看完B看
    - 同时访问 A看段时间B看再A
#### 虚拟virtual
- 将一个物理实体变成若干个逻辑上的对应物
    - 分时复用 虚拟处理机和I/O 虚拟存储技术（逻辑上扩大内存）
    - 空分复用 
        - 电信业将宽的信道变窄
        - 用存储器的空闲空间存放运行其他多道程序（提高内存利用率）
#### 异步asynchronism 
- 进程的异步性，进程以人们不可预知的速度向前推进
#### 1.4 OS的主要功能
- 处理机管理功能
    - 进程控制
    - 进程同步
    - 进程通信
    - 调度
        - 作业调度
        - 进程调度
- 存储器管理功能
    - 内存分配
    - 内存保护
    - 地址映射
    - 内存扩展
- 设备管理功能 I/O缓存
    - 缓存管理
    - 设备分配
    - 设备处理
- 文件管理功能
- 接口功能
#### 1.5 OS设计
- 第一代 无结构OS
- 第二代 模块化结构OS 
    - 按1.4的功能分模块成树状，会死锁
- 第三代 分层式结构OS 
    - 只为其后提供服务，只让其前提高服务/自底向上
- C/S 客户机 服务器 网络系统 
    - 客户发送请求，服务器接收并发送消息，客户机接收信息
- B/S 
- 面对对象的程序设计
    - 类/对象/继承
- 现代OS 微内核OS结构  
## 2 进程的描述与控制
### 2.1 
- 进程
    - 进程是程序的一次执行
    - 进程是程序及其数据在处理机上的顺序执行所发生的活动
    - 进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单元
    - 特征
        - 动态性 并发性 独立性 异步性
### 2.2 PCB 
- PCB process control block
    - 标识符
    - 进程基本状态 就绪ready 执行running 阻塞block
    - 地址空间，数据 封闭
    - 优先级 调度先后顺序
    - cpu的状态 
        - 两状态模型 
        - 三状态模型
        - 第一种五状态模型
        - 第二种五状态模型
        - 七状态模型
    - 同步
- 进程实体 => PCB + 程序 + 数据
- 进程控制过程
    - 创建与终止
    - I/O 请求（阻塞）与 I/O 完成（唤醒）
    - 挂起与激活
    - 调度 时间片完
    - 所有进程都是可管理的 （增删改查）
- 进程树规定了进程管理的权限
- PCB 的组织方式
    - 线性 连接 索引
### 2.3 进程控制
- 创建进程
    - who OS 父进程 用户
    - how
        - 申请PCB在空白PCB队列
        - 初始化PCB
        - 申请资源
        - 将PCB插入状态队列
- 终止进程
    - who OS 父进程 用户
    - how
        - 修改PCB状态
        - 释放资源
        - 清除PCB数据
        - 插入空的PCB队列
- 阻塞进程
    - who 自身 程序中有阻塞指令 sleep
    - how 
        - 阻塞原语
        - 找PCB修改状态 执行->阻塞
        - 将PCB放入阻塞队列
- 唤醒
    - who 其他进程
    - how 
        - 唤醒原语
        - 找PCB修改状态
        - 将PCB插入就绪队列
- 挂起
    - who OS 父进程 用户
    - how 
        - 找PCB，修改状态
        - 将PCB放入挂起队列
        - 拆分实体
            - 释放资源
            - 将程序和数据调入外存
## 第三章 处理机调度与死锁
### 3.1 处理机调度的层次和调度算法的目标
> 处理机调度的层次
- 高级调度（high level scheduling）
    - 又称长程调度或作业调度 用于多道批处理系统
    - 根据某个算法，将外存上处于后备队列中的哪几个作业调入内存的，并为其创建进程，分配必要资源和放入就绪队列
- 低级调度（low level scheduling）
    - 又称进程调度或短程调度，调度对象是进程或内核级线程 用于多道批处理系统，分时和实时系统
    - 根据某个算法，决定就绪队列中哪个进程获得处理机，并分配程序将处理机分配给选中的进程
- 中级调度（intermediate scheduling） 
    - 又称内存调度，为提高内存利用率和系统吞吐量
    - 把那些暂时不能运行的进程调入外存，此时进程的状态成为就绪驻外存状态或挂起状态
    - 当它们已具备运行条件且内存又稍有空间时，由中级调度来决定，把外存的上的那些已具备运行条件的就绪进程在重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待。
    - 实际上是存储器管理中的对换功能，见第四章
> 处理机调度算法的目标
- 共同目标
    - 资源利用率
        - CPU的利用率 = CPU有效工作时间/CPU有效工作时间 + CPU 空闲等待时间
    - 公平性 不会饥饿现象 但要考虑优先级
    - 平衡性 不同的类型进程有需求 如计算型 I/O型 需要使资源利用率都高
    - 策略强制执行
- 批处理系统的目标
    - 平均周转时间短
        - 周转时间：从作业被提交给系统开始到作业完成为止的时间间隔
            - 作业在外存后备队列上等待的时间
            - 进程在就绪队列上等待的时间
            - 进程在CPU上执行的时间
            - 进程等待 I/O 操作完成的时间
        - 平均周转时间 每个作业的周转时间/作业数
    - 系统吞吐量高
        - 单位时间内系统所完成的作业数
        - 多选短作业运行这一指标高
    - 处理机利用率高
        - CPU 空闲等待时间少
        - 多选长作业运行这一指标高
- 分时系统的目标
    - 响应时间快
        - 用户提交请求开始到输出处理结果为止
    - 均衡性
        - 复杂任务响应时间可以长，但简单任务响应时间要短
        - 均衡性，是指系统响应时间快慢与用户请求的复杂程度相对应
- 实时系统的目标
    - 截止时间的保证
        - 截止时间：某任务必须开始的最迟时间或必须完成的最迟时间
        - HRT硬实时任务 必须保证 SRT 软实时任务 基本保证
    - 可预测性
        - 在多媒体系统（SRT）中视频应连续播放，这就提供了请求的可预测性
        - 若系统采用了双缓冲，即实现了第 i 帧的播放和第 i+1 帧的读取并行处理，进而提高其实时性
### 3.2 JCB 作业与作业调度
#### 3.2.1 批处理系统中的作业

- 作业管理
    - JCB引入 cpu memory/disk I/O
    - 作业与作业实体（JCB+程序）
    - 作业状态与控制
        - 作业控制引起作业状态转化的操作
        - 创建 调度 阻塞 唤醒 终止
        - 调度 依据一定的策略，将资源分配给某个作业，或将资源从某个作业移除的过程
        - 调度算法 资源分配或移除所依据的策略
- JCB 结构 job control block
    - 标识符
    - cpu 信息
        - 调度信息
        - 账户
        - 状态 running block ready
        - 资源需求请求
    - address pointer
    - I/O well
    - 时间指标 => 度量性能
    - 资源性能
- JCB ad
    - 简单整体执行
- JCB disad
    - 资源需求大，资源利用率低
    - 内存需求大不支持虚拟内存
- 调度算法的指标
    - 登录时间 disk -> memory
    - 开始时间 memory -> cpu
    - 结束时间 cpu -> memory
    - 登出时间 memory -> disk
- 面对一个 JCB 的指标
    - 周转时间 = 结束时间 - 登录时间 
    - 执行时间 = 结束时间 - 开始时间(小于周转时间)
    - 加权周转时间 = 周转时间/执行时间
- 面对一组 JCB 的指标
- 平均周转时间 = （作业1的周转时间+作业2的周转时间+...+作业n的周转时间）/n
- 平均带权周转时间 = （作业1的加权周转时间+作业2的加权周转时间+...+作业n的加权周转时间）/n
- 先来先服务 FCFS first come first service
    - 有利于于长作业不利于短作业
    - 简单 执行序列和到达序列一致
    - 大数优先
- 短作业优先 SJF short job first
    - 小数优先
    - 优化了FCFS 降低了CPU等待时间
    - 但有可能出现饥饿状态 长作业永远不执行
    - 执行序列和到达序列不一致
- 优先级调度算法priority-scheduling algorithm PSA
- 高响应比优先调度算法 highest response ratio next HRRN
    - 平衡了 SJF （考虑运行时间） 和 FCFS （考虑等待时间）
    - 优先级可变
        - 优先级 = 响应比 = 1 + 等待时间/要求服务时间
        - 等待时间 + 要求服务时间 = 响应时间
### 3.3 进程调度
#### 3.3.1 进程调度的任务，机制和方式
- 进程调度的任务
    - 保存处理机的现场信息 断点保护
    - 按某种算法选出进程
    - 把处理器分配给进程 断点恢复
- 进程调度机制
    - 排队器
    - 分派器
    - 上下文切换器
- 进程调度的方式
    - 非抢占方式nonpreemptive mode
        - 把处理机分配给某进程后，就一直让它运行到结束或发生阻塞
        - 难以满足交互性作业和实时任务
        - 在该方式下，引起进程调度的因素可以归结为
            - 进程结束或阻塞
            - I/O请求
            - 在进程通信或同步过程中
    - 抢占方式preemptive mode
        - 允许暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一个进程
        - 可以防止一个长进程长时间的占用处理机，更加公平
        - 在分时系统中，只有抢占方式可能实现人机交互
        - 在实时系统中抢占方式能够满足实时任务的需求。但复杂
    - 抢占方式的原则
        - 优先权原则
        - 短进程优先原则
        - 时间片原则
#### 3.3.2 轮转调度算法
> 在分时系统中是基于时间片的轮转round robin RR 调度算法
- 轮转法的基本原理
    - 根据 FCFS 排成一个就绪队列，并可以设置每隔一定时间间隔即产生一个中断 
- 轮转法切换机制
    - 若一个时间片尚未用完，正在运行的进程便已经完成，就立即激活调度程序，将它从就绪队列删除，再调度就绪队列中对首的进程运行，并启动新的一个时间片
    - 再一个时间片用完时，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序将把它送到就绪队列的队尾
- 时间片大小的确定
    - 时间片小有利短作业 时间片大退化成 FCFS 
> 其隐含所有进程的紧迫性一致
#### 3.3.3 优先级调度算法
- 优先级调度算法的类型
    - 非抢占式优先级调度算法
    - 抢占式优先级调度算法
- 优先级的类型
    - 静态优先级
        - 在创建进程时确定的，在整个运行期间保持不变
        - 依据 
            - 进程类型 系统进程高于用户
            - 进程对资源的需求 资源要去少的高
            - 用户要求
        - 这种方式简单易行系统开销小，但不精确
    - 动态优先级
        - 在创建进程时确定的，然后其值随进程的推进或等待时间的增加而改变，以便获得更好的调度性能
#### 3.3.4 多队列调度算法
- 将进程就绪队列拆分成若干个，将不同类型或性质固定在不同的队列中，不同的队列使用不同的调度算法
#### 3.3.5 多级反馈队列
- 设置多个就绪队列并为其设置不同的优先级
    - 第一最高时间片最小第二次之
- 每个队列都采用 FCFS 算法
    - 当新进程进入内存后，首先将它放入第一队列末尾
    - 若其完成则退出
    - 若其未完成进入第二队列未尾，若还未完成进入第三队列
    - 重复上一个，直到最后一个队列使用 RR 
#### 3.3.6 基于公平原则的调度算法
- 保证调度算法
    - 若系统中有 n 个相同类型的进程同时运行 保证每个进程都获得相同的处理机时间 1/n
- 公平分享调度算法
    - 各个用户拥有不同的进程数，要让用户获得相同的处理机时间，或所要求的时间比例
### 3.4 实时调度
#### 3.4.1 实现实时调度的基本条件
- 提供必要的信息
    - 就绪时间：某任务成为就绪状态的起始时间，
    - 开始截止时间 因为一个系统中有多个用户/进程，则二者有所不同
    - 完成截止时间
    - 处理时间
    - 资源要求
    - 优先级
- 系统处理能力强
    - 提供方法 采用单处理机系统增强其处理能力 或采用多处理系统
- 采用抢占式调度机制
    - 在有 HRT 中广泛采用
- 具有快速切换机制
    - 对中断的快速响应能力
    - 快速的任务分派能力
- 实时调度算法的分类
    - 非抢占式调度算法
    - 抢占式调度算法
        - 基于时钟中断的抢占式优先级调度算法
        - 立即抢占的优先级调度算法
#### 3.4.2 最早截止时间优先 EDF earliest deadline first
- 根据任务的截止时间确定任务的优先级
    - 非抢占式调度方式用于非周期实时任务
    - 抢占式调度方式用于周期实时任务
#### 3.4.4 最低松弛度优先 LLF least laxity first 小数优先       
    