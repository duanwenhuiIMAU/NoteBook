# 数据结构
## 6 树与二叉树
### 6.1 树的定义和基本术语
>    树 是n（n >= 0）个结点的有限集 
- 在任意一颗非空树中  有且仅有一个特定的称为根（Root）的结点
- 当 n > 1 时，其余节点可分为 m ( m > 0 ) 个互不相交的有限集 T1， T2，... Tm, 其中每个集合本身又是一颗树， 并称为根结点的子树(SubTree)；
>
    树的中心点
        n = 0 空树
        n = 1 根结点
        n >= 2 子树 互不相交 递归  层次
> 
***
    一颗树（ n >= 2 ）                        
                        A 
                    B   C    D
                  E  F  G  H I J  
                 K L       M
***
    如上图树是有 13 个结点的树，其中 A 是根，其余节点分成 3 个互不相交的子集：
    T1 = { B,E,F,K,L }, T2 = { C,G }, T3 = { D,H,I,J,M }; 
    T1,T2 和 T3 都是根 A 的子树，且本身也是一颗树。即 例如 T1, 其根为 B, 
    其余节点分成 2 个互不相交的子集： T11 = { E,K,L }, T12 = { F }; T1和T2 都是根 B 的子树。
    而 T11 中 E 是根，{ K },{ L } 是 E 的两棵互不相交的子树；其本身又是只有一个根结点的树。
> 树的节点 包含一个数据元素及若干指向其子树的分支。

> 结点的度（Degree）结点拥有的子树数。

> 叶子（Leaf）又称 终端结点 是度为 0 的结点。

> 分支结点 又称 非终端结点 是度不为 0 的结点。

> 树的度 是 树内各结点的度的最大值。

> 孩子（Child）是结点的子树的根。该结点是孩子的双亲（Parent）。同一双亲的孩子互为兄弟（Sibling）。
    
    如 上图 B 为 A 的子树 T1 的根，则 D 是 A 的孩子，而 A 是 D 的双亲。 B, C 和 D 互为兄弟

> 结点的祖先 是从根到该结点所经过分支上的所有结点 如上图 M 的祖先为 A D H 。

> 结点的子孙 以某一节点为根的子树中的任一结点。 如上图 B 的子孙为 E K L。

> 节点的层次（Level）从根结点开始定义，根为第一层，根的孩子为第二层。若某结点在第 L 层，则其子树的根就在第 L + 1 层。其双亲在同一层的结点互为堂兄弟。树中的结点的最大层次为树的深度（Depth） 或高度。
    
    如上图 结点 G 与 E, F, H, I, J 互为堂兄弟。树的深度为 4。
> 如果将树的结点的各子树的看成从左至右是次序的即不能互换的则为有序树。否则为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。

> 森林（Forest）是 m （ m >= 0 ） 颗互不相交的树的集合。
#### 树的计算
    1. 一颗有 n 个结点的树，它的所有结点的度数之和为 n-1
        证明 ： 
                当 n = 0 ，无结点
                当 n = 1 ，一个结点， 一个度
                当 n >= 2  
                第一层次的根节点只有一个方向的关系 即不是任何结点的孩子 并且其度不为 0  可以理解为第一层次的根节点不被任何一层结点所拥有 
                故计算时需要减去第一层次的根节点的一个度 即 n-1 
    2. 在一颗度为 4 的树 T 中，如果有 20 个度为4的结点，10 个度为 3 的的结点，1 个度为 2 的结点，10 个度为 1 的结点， 则树 T 的叶结点数为  
        由 1. 知 
              总结点数 = 所有结点的度和 + 1
            其他概念 根与子树的连线叫边  则结点数 = 边 - 1
            则总结点数 = 20 * n4 + 10 * n3 + n2 + 10 * n1 + n0 * 0 + 1 = 20 * 4 + 10 * 3 + 2 + 10 * 1 + 1 = 123 = n1 + n2 + n3 + n4 + n0
            n0 = 总结点数 -（ n1 + n2 + n3 + n4 ）= 123 - 20 - 10 - 1 -10 = 8
    3. 对于一颗具有 n 个结点 度为 4 的树的高度至多是 n-3;
    4. 对于一颗度为 4 高为 h 的树 其结点至少是 h+3;
         如图
              A
              B
              C
              D E F H
### 6.2 二叉树
#### 6.2.1 二叉树的定义   
    最多 2 个结点 有序
    二叉树的五种基本形态  空树 根树 根树加左 根树加右 根树加左右
#### 6.2.2 二叉树的性质
- 1. 在二叉树的第 i 层上至多有 $2^{(i-1)}$ 个结点（i>=1）
- 2. 深度为 k 的二叉树至多有 $2^{k-1}$ 个结点（k>=1）
- 3. 对于任何一颗二叉树 T，如果其终端结点数为 $n_0$，度为 2 的结点数为 $n_2$，则有 $n_0 = n_2 + 1$

    - 满二叉树是一颗深度为 k 且有 $2^{k-1}$ 个结点的二叉树
    - 完全二叉树是深度为 k 的，有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 k 的
    - 满二叉树中编号（至上而下，从左到右）从 1 至 n 的结点一一对应
- 4. 具有 n 个结点的完全二叉树的深度为 log2/n（向下取整）+ 1
- 5. 如果对一颗有 n 个结点的完全二叉树（其深度为 $log_2^n$（向下取整）+ 1）的结点按层序编号（至上而下，从左到右），
    则对于任一结点 i （1 <= i <= n）,有
    - 如果 i = 1，则结点 i 是二叉树的根，无双亲；如果 i > 1,则其双亲parent是结点 i/2（向下取整）
    - 如果 2i > n，则结点 i 无左孩子（即结点 i 为叶子结点） ；否则其左孩子Lchild（i）是结点 2i
    - 如果 2i+1 > n，则结点 i 无右孩子（即结点 i 为叶子结点） ；否则其右孩子Rchild（i）是结点 2i+1  如下图
***
                    i/2（向下取整）
                i            i+1
            2i    2i+1   2i+2   2i+3
#### 6.2.3 二叉树的储存结构
- 1. 顺序储存结构  
        由性质 2 知最坏的情况下，一个深度为 k 且 只有 k 个结点的单支数 却需要长度为 $2^{k-1}$ 的一维数组
        其位置表示其关系  性质 5
- 2. 链式储存结构 
        双亲表示
        左右孩子表示 二叉链表 
        左右孩子加双亲表示 三叉链表
        左子右兄表示
        线索链表 = 左右孩子表示 + 标识域（标识其指针为孩子还是直接前驱（左指针域）和直接后继（右指针域））
#### 6.2.4 二叉树的计算  
    前序遍历 根左右
    中序遍历 左根右
    后序遍历 左右根
    知中序和另一序求二叉树的方法
        1.前序第一个为根结点 后序的最后一个为根结点
        2.中序中对应的结点两侧分左右数
        3.递归
#### 6.2.5 二叉树与森林的转换
***
    左子右兄表示
              森林               对应的二叉树
         A      E     G                A
      B  C  D   F    H  I          B       E
                        J           C    F   G
                                     D      H
                                             I
                                            J
***                                   
#### 6.2.6 赫夫曼树（最优二叉树）
    //这一部分还有例题
    赫夫曼树是带权路径长度（WPL）最小的二叉树
    小的在下 大的在上 两小相加 小于其他 则为空一
## 7 图
### 7.1 图的定义和术语
> 顶点（Vertex）图中数据元素 

> V是顶点的有穷非空集合 

> VR是两个顶点之间的关系的集合 

> 若 <v,w> 属于 VR 则 <v,w> 表示从 v 到 w 的一条弧（Arc），v 为弧尾（Tail）或初始点（Initial node），
w 为弧头（Head）或终端点（Terminal node），这样的图为有向图（Digraph）

> 若 <v,w> 属于 VR 必有 <w,v> 属于 VR 这样的图叫无向图（Undigraph） 无向图的邻接矩阵对称 
    以无序对（v,w）代替这两个有序对，表示 v 和 w 之间的一条边（Edge）

    设 顶点数为 n，边或弧数为 e，
- 无向图 $0 <= e <= 1/2 n (n-1)$ 当 $e = 1/2 n (n-1)$ 为完全图
- 有向图 $0 <= e <= n(n-1)$ 当 $e =  n (n-1)$ 为有向完全图
- 稀疏图 $ e < n log_2^n $ 反之，稠密图
> 对于无向图 边连两点，则两点互为邻接点（Adjacent）其边依附于两点，或其边于两点相关联。 
    
    顶点 v 的度（Degree）是和 v 相关的边的数目，记为 TD（v）。

>   对于有向图A 如果弧 <v,w> 属于 A，则称顶点 v 邻接到 w ，顶点 w 邻接自 v ，弧 <v,w>于两点相关联。

    以顶点 v 为头的弧数目称为 v 的入度（Indegree），记为ID(v)。
    以顶点 v 为尾的弧数目称为 v 的出度（Outdegree），记为OD(v)。（树是只有出度无入度）
    顶点 v 的度（Degree）TD(v)= ID(v) + OD(v)。
> 有 n 个顶点 e 条边或弧的图，满足 $$ e = 1/2\sum_{i=1}^n TD(v_i) $$

>  无向图中从顶点 v 到 w 的路径（Path）是一个顶点序列，如果是有向图则路径有向。路径长度是路径上边或弧的数目。

    第一和最后一个顶点相同的路径叫 回路 或 环（Cycle）。

    顶点不重复叫简单路径。顶点不重复的环叫简单环。

    无向图 如果从顶点 v 到 w 有路径，则称 v 和 w 是连通的。

    任何两顶点都连通是连通图（Cennected Graph）。

    连通分量（Connected Component）是无向非连通图中极大连通子图。

    一个连通图的生成树是一个极小连通子图，它含有图中全部顶点，但只有足以构成一课树的 n-1 条边

    在有向图叫 强连通图 强连通分量 生成树（极小连通子图）（有无向图均有这个概念）。

    对于非连通图，由各点连通分量的生成树构成的集合，称为该非连通图的生成森林。
### 7.2 图的储存结构
#### 7.2.1 数组表示法（邻接矩阵）
> 用两个数组分别储存数组元素（顶点）的信息和数据元素之间的关系（边或弧）的信息。

    有向图的非对称，无向图的对称
    // -------图的数组表示法（邻接矩阵）---------
        
    #define INFINITY INT_MAX                  // 最大值
    #define MAX_VERTEX_NUM 20                 // 最大顶点个数
    typedef enum {DG,DN,UDG,UDG} GraphKind;   // 有向图，有向网，无向图，无向网
    typedef struct ArcCell{
        VRType adj;         // VRType是顶点关系类型。
                            //对无权图，用 1 或 0 表示表示相邻否
                            //对带权图，则为权值类型
        InfoType *info;     //该弧相关的指针
    };
    typedef struct Graph{
       VertexType vexs[MAX_VERTEX_NUM]; //顶点数量
       AdjMatrix arcs;                  //邻接矩阵
       int vexnum, arcnum;              //图的当前顶点数和弧数
       GraphKind kind;                  //图的种类
    };
> 借助于邻接矩阵容易判定任意两个顶点之间是否有边或弧相连，并容易求得各个顶点的都
- 无向图，顶点 $v_i$ 的度是连接矩阵中第 $i$ 行或第 $i$ 列的元素和
$$ TD(v_i)= \sum_{j=0}^{n-1}A[i][j](n=MAX \_VERTEX\_NUM) $$
- 有向图，第 $i$ 行的元素之和为顶点的 $v_i$ 的出度 $OD(v_i)$,第 $j$ 列的元素之和的入度$ID(v_j)$
#### 7.2.2 邻接表
>对图的每个顶点建立一个单链表，第 $i$ 个单链表中的结点表示依附于顶点 $v_i$ 的边。

||表结点||
|-|-|-|
|adjvex|nextarc|info|

>每个结点由 3 个域组成，其中邻接点域（adjvex）指示与顶点 $v_i$ 邻接的点在图位置，链域（nextarc）指示下一个边或弧的结点，数据域储存和边或弧相关的信息，如权值。

    // -------图的邻接表---------
    #define MAX_VERTEX_NUM 20                 // 最大顶点个数
    typedef struct ArcNode{
       int adjvex;                      //该弧所指向的顶点的位置
       struct ArcNode *nexttarc;        //指向下一条弧的指针
       InfoType *info;                  //该弧相关的指针
    };

    typedef struct VNode{
       VertexType data;                 // 顶点信息          
       ArcNode *firstarc;               // 指向第一条依附该点的弧的指针
    }VNode,AdjList[MAX_VERTEX_NUM];

    typedef struct ALGraph{
      AdjList vertices;
      int vexnum,arcnum;//图的当前顶点数和弧数
      int kind;//图的种类标志
    }ALGraph;
> 若无向图中有 n 个顶点，e 条边，则它的邻接表需要 n 个头结点，2e 个表结点。显然,在边稀疏的$(e<< n(n-1)/2)$的情况下，用邻接表表示比邻接矩阵节省存储空间，当和边相关的信息较多时更时如此。

> 对于稠密图（无向稠密图更是这样）用邻接矩阵更好
- 在无向图的邻接表中，顶点 $v_i$ 的度恰为第 $i$ 个链表的结点数，
- 在有向图的邻接表中，第 $i$ 个链表的结点数只是顶点 $v_i$ 的出度，若求其入
度必须遍历整个邻接表。
> 逆邻接表 =》对每个顶点 $v_i$ 建立一个链接以 $v_i$ 为头的弧的表可以方便的求有向图的入度

> 在建立邻接表或逆邻接表时，若输入的顶点信息即为顶点的编号，则建立邻接表的时间复杂度O（n+e）

> 否则，需要通过查找才能得到顶点的在图中位置，则时间复杂度为O（n*e）

> 在邻接表上容易找到任一顶点的第一个邻接点和下一个邻接点，但要判定任意两个任意两个顶点的之间是否有边或弧相连，则需要搜索第 $i$ 个和第 $j$ 个链表，这点不仅邻接矩阵方便
#### 7.2.3 十字链表
> 十字链表 = 邻接表 + 逆邻接表

    在十字链表中，对于有向图中每一条弧有一个结点，对应于每一个顶点也有一个结点。
|||弧结点|||||顶点结点||
|-|-|-|-|-|-|-|-|-|-|
|tailvex|headvex|hlink|tlink|info||data|firstin|firsout|
- 在弧结点中有 5 个域
    - 尾域和头域分别指示弧尾和弧头这两个顶点在图中的位置
    - 链域 hlink 指向弧头相同的下一条弧 tlink 弧尾相同的下一条弧
    - info 域指向该弧的相关信息
- 在顶点结点中有 3 个域 
    - data 存储和顶点相关的信息如顶点名称
    - firstin 和 firsout 为两个链域分别指向以该顶点为弧头或弧尾的第一个弧结点
>
    //----- 有向图的十字链表存储表示 -----
    #define MAX_VERTEX_NUM  20    // 最大顶点个数
    typedef struct ArcBox{              // 弧结点 
        int  tailvex, headvex;   // 该弧的尾顶点和头顶点的位置 
        struct ArcBox  *hlink, *tlink;  // 弧头相同和弧尾相同的弧结点的链域 
        InfoType          *info;     // 该弧相关信息的指针  
    }ArcBox;
    typedef struct VexNode{      // 顶点结点
      VertexType      data;       // 顶点信息
      ArcBox            *firstin, *firstout;  // 分别指向该顶点第一条入弧和出弧
    }VexNode;
    typedef struct {
        VexNode   xlist[ MAX_VERTEX_NUM ];  // 表头向量
        int              vexnum, arcnum;  // 有向图的顶点数和弧数
    }OLGraph;
#### 7.2.4 邻接多重表(Adjacency Multilist)
> 邻接多重表是无向图的另一种链式存储结构
- 邻接多重表和邻接表的对比
    - 邻接表中容易求得顶点和边的各种信息，其用两个结点表示一条边
    - 邻接多重表可以对已被搜索过的边进行做标记或删除一条边。其用一个
> 邻接多重表的结构和十字链表类似，在邻接多重表中，每一条边用一个结点表示，如下

||||边的信息|||||顶点的信息|
|-|-|-|-|-|-|-|-|-|
|mark|ivex|ilink|jvex|jlink|info||data|firstedge 
> 边的
- mark 为标准域可标记其是否被搜索过
- ivex 和 jvex 为该边依附的两个顶点在图中的位置
- ilink 指向下一条依附于顶点的 ivex 的边
- jlink 指向下一条依附于顶点的 jvex 的边
- info 和边相关的各种信息指针域
> 顶点的
- data 存储和该顶点相关的信息
- firstedge 指示第一条依附于该顶点的边
### 7.3 图的遍历
> 图的遍历 -> 从图的某一个顶点出发访遍图的其余顶点，且使每个顶点只被访问一次
    
    避免同一顶点被多次访问，在图的遍历中，必须记下每个已访问过的顶点。
    为此需要一个辅助数组 visited[0...n-1],它的初始值定为假，一旦访问了顶点 v_i，就把 visited[i] 设置为真或被访问的次序号。
#### 7.3.1 深度优先搜索(Depth_First Search)
> 深度优先搜索遍历类似于树的先根遍历。需要使用递归或栈

    假设初始状态是图中所有顶点未曾被访问，则深度优先搜索可从图中的某个顶点 v 出发，
    然后依次从 v 的未被访问的邻接点出发深度优先遍历图，直到图中所有和 v 有路径相通
    的顶点都被访问到，若此图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点做为
    起点，重复上述过程，直到图中所有顶点都被访问
#### 7.3.2 广度优先搜索(Broadth_First Search)
> 广度优先搜索遍历类似于树的按层次遍历。需要队列
### 7.4 图的连通性问题
#### 7.4.1 无向图的连通分量和生成树
    无向图 如果从顶点 v 到 w 有路径，则称 v 和 w 是连通的。

    任何两顶点都连通是连通图（Cennected Graph）。

    对于非连通图，由各点连通分量的生成树构成的集合，称为该非连通图的生成森林。

    一个连通图的生成树是一个极小连通子图，它含有图中全部顶点，但只有足以构成一课树的 n-1 条边

> 连通图 -> 深度/广度 -> 一个出发点 -> 所有顶点(深度优先生成树/广度优先生成树)

> 不连通图 -> 深度/广度 -> 大于一个出发点 -> 部分顶点(深度优先生成森林/广度优先生成森林)

    其算法的时间复杂度和深度/广度优先搜索遍历相同

    连通分量 <=> 极大连通子图 = 在无向非连通图
    生成树 <=> 极小连通子图 = 在无向连通图
    生成森林 <=> 极小连通子图构成的集合 = 在无向非连通图
    在有向图叫 强连通图 强连通分量 生成树。
#### 7.4.2 有向图的强连通分量
    其算法的时间复杂度和深度优先搜索遍历相同
#### 7.4.3 最小生成树（带权）
> 最小生成树的 MST 性质

    假设 N = ( V, { E } )是一个连通网，U 是顶点集 V 的一个非空子集
    若 (u,v) 是一条具有最小权值(代价)的边，其中 u 属于 U，v 属于 V-U，
    则必存在一颗包含边 (u,v) 的最小生成树
> 应用此原理的有普里姆（Prim）和 克鲁斯卡尔（Kruskal）算法

> 普里姆（Prim）算法 
    
    顶点确定找权最小的边，递归到这个顶点的邻接点再找除该边以外的权值最小的边
    直到构成生成树

假设 $N = ( V, \{ E \} )$是一个连通网，TE 是 N 上最小生成树的边的集合。
    
算法从 U = $\{u_0\}(u_0 \in V)$,TE={},重复执行下述操作

在所有的 $u \in U$,$v \in {V-U}$ 的边中找一个 $(u,v) \in E$ 中在一个代价最小的边 $(u_0,v_0)$

并入集合 TE，同时 $v_0$ 并入 U，直至 $U = V$，此时 TE 中必有 n-1 条边，则 T = (V,{TE}) 为最小生成树
>  克鲁斯卡尔（Kruskal）算法

    将权最小的边的两个相关点两两相连，再将其他边中权值小的于之相连
    直到构成生成树。
### 7.5 有向无环图以及应用
> 有向无环图是一个无环的有向图（DAG）

> 对于无向图，深度遍历遇到回边(指向已访问过的顶点的边)，则必然存在环
- 用于
    - 描述公共子式对于相同子式共享
    - 有先后顺序的工程
        - 该工程是否能顺利进行 -> 进行拓扑排序
        - 估计整个工程的最短时间 -> 求关键路径
#### 7.5.1 拓扑排序（Topological Sort）
> 若集合 X 上的关系 R 是自反的，反对称的和传递的，则称 R 是集合 X 上的偏序关系。

> 偏序是集合中仅有部分成员之间可以比较，全序是集合中的全体成员均可比较

> 拓扑排序 由某个集合上的一个偏序得到该集合的一个全序

> 拓扑排序是否成功取决于有向图是否有环

> 拓扑排序的方法
- 在有向图中选一个没有前驱的顶点且输出
- 从图中删除该顶点和所有以它为尾的弧

> AOV-网（Activity On Vertex Network）

    用顶点表示活动，用弧表示活动间的优先关系的有向图称为顶点表示活动的网（Activity On Vertex Network）
>
    在网中若顶点 i 到顶点 j 有以条有向路径，则 i 是 j 的前驱，j 是 i 的后继，若<i,j>是网中的一条弧，
    则 i 是 j 的直接前驱，j 是 i 的直接后继
#### 7.5.1 关键路径（有问题）
> AOE-网(Activity On Edge)是边表示活动的网

    AOE-网是一个带权的有向无环图，顶点表示事件（Event），弧表示活动，权表示活动持续的时间
> 网中只有一个入度为零的点（称为源点）和一个出度为零的点（称为汇点）

> 从源点到汇点的最长路径称为关键路径，关键路径的长度是完成整个工程的最短时间。

即$$\sum_{a_i}^{a_j}= max$$
    
    普里姆（Prim）算法求其最短时间。
> 关键路径上的活动称为关键活动，关键活动是影响整个工程进度的关键。则求关键路径即求关键活动
- ve(i)表示事件的最早发生时间。也就是该顶点的前驱弧的时间之和
- e(i)表示活动 $a_i$ 的最早开始时间。也就是它的前驱们的时间之和
> ve(i) = e(i)
- vl(i)表示事件的最迟发生时间。也就是该顶点后驱们的时间之和
- l(i)表示活动 $a_i$ 的最晚开始时间。也就是它的后驱们的时间
- l(i) - e(i)表示完成活动 $a_i$ 的时间余量
- l(i) = e(i) 的活动叫关键活动
> 关键路径算法
- 从源点出发，
### 7.6 最短路径
> 所谓最短路径问题，就是在带权有向图中，求两顶点间长度为最短的路径。路径长度定义为路径上的弧所带权的总和。
#### 8.6.1  从某个源点到其余各顶点的最短路径（单源最短路径问题）
> 路径上第一个顶点称作源点，最后一个顶点称作终点。

> 所谓单源最短路径问题，就是从某一顶点v0 出发，找从它到图中其他各个顶点的最短路径。

> Dijkstra算法的基本策略是：按最短路径长度递增的次序求得各条最短路径。
    假定：从源点v0到顶点v1的最短路径在所有最短路径中长度最短，从v0到v2的最短路径长度次短……

    长度最短的最短路径的特点: 
    在这条路径上，必定只含一条弧<v0,v1>，并且这条弧在以v1为尾的弧中权值最小
    它只可能有两种情况：
        或者是直接从源点到终点(只含一条弧)； 
        或者是，从源点经过顶点v1，再到达终点(由两条弧组成)。
    其余最短路径的特点：
        它或者是直接从源点到终点(只含一条弧)； 或者是，从源点经过已求得最短路径的顶点，再到达终点。
## 9 查找
> 查找表(Search Table)是由同一类型的数据元素(或记录)构成的集合。
- 查找表的操作
    - 查询某个“特定的”元素是否在查找表中
    - 检索某个“特定的”元素的各种属性
    - 在查找表中插入一个元素
    - 从查找表中删除一个元素
> 静态查找表（Static Search Table）只有前两个功能

> 动态查找表 (Dynamic Search Table) 有四个功能

> 关键字 (Key) 是数据元素 (或记录) 中某个数据项的值，用它可以标识 (识别) 一个数据元素 (或记录)。
- 主关键字 (Primary Key) 若此关键字可以唯一地标识一个记录（对不同的记录，其主关键字均不同）
- 次关键字 (Secondary Key) 若用识别若干记录的关键字。
- 注 当数据元素只有一个数据项时，其关键字即为该数据元素的值
> 查找 (Searching) 根据给定的某个值，在查找表中确定一个其关键字等于给定的记录或数据元素。
- 若存在这样一个记录，则查找成功，此时查找的结果为给出整个记录的信息，或指示该在查找中的位置
- 若表中不存在关键字等于给定值的记录，则查找不成功，此时查找的结果可给出一个“空”记录或“空"指针
### 9.1 静态查找表
#### 9.1.1 顺序表的查找
> 顺序查找 (Sequential Search)的操作过程

    从表中最后一个记录开始，逐个进行记录的关键字和给定值的比较，若某个记录的关键字和给定值比较相等，
    则查找成功，找到所查找记录；反之，若直至第一个记录，其关键字和给定值比较都不等，则查找不成功。
    平均查找长度(Average Search Length) 为确定记录在查找表中的位置需要和给定值进行比较的关键字个数
    的期望值称为查找算法查找成功的平均查找长度
>   等概率的顺序查找成功的平均查找长度为
$${ASL}_{ss}=\sum_{i=1}^nP_iC_i=1/n\sum_{i=1}^n(n-i+1)=(n+1)/2$$
>   等概率的顺序查找成功与不成功的平均查找长度为
$${ASL}_{ss}=1/(2n)\sum_{i=1}^n(n-i+1)+(n+1)/2=3/4(n+1)$$
#### 9.1.2 有序表的查找
> 折半查找(Binary Search)的查找过程是：

    先确定待查记录所在的范围(区间)，然后逐步缩小范围直到找到或找不到该记录为止
        初始
    指针 low 和 high 分别指示待查元素所在范围的下界和上界，指针 mid 指示区域的
    中间位置，mid = （low + high）/2(向下取整)
        首先
    令中间位置和给定值比较
        若小于令 high = mid - 1
        若大于令 low = mid + 1
    然后令 mid = （low + high）/2(向下取整)
    再令中间位置和给定值比较,重复直到 mid 指针和给定值相等(查找成功)，或 low > high (查找不成功)
> 折半查找在成功时和给定值进行比较的关键字个数至多为$log_2^n+1$(向下取整)

> 折半查找在不成功时和给定值进行比较的关键字个数最多不超过为$log_2^n+1$(向下取整)

> 折半查找的平均查找长度（成功时）

$${ASL}_{bs}=\sum_{i=1}^nP_iC_i=1/n\sum_{j=1}^hj*2^{j-1}=(n+1)/nlog_2(n+1)-1$$

当 n > 50 时 $${ASL}_{bs}=log_2(n+1)-1$$

> 折半查找只能用于有序表，且限于顺序储存结构

> 以有序表表示的静态查找表时，进行查找的方法除折半查找之外，还有斐波那契查找和插值查找
- 斐波那契查找
    - 其根据斐波那契序列的特点进行分割
    - 其平均性能比折半查找好，但是最坏的情况下的性能 O（$log_n$）却比折半查找差，
    - 它的另一个优点是只需进行加减运算
- 插值查找
    - 插值查找只适用于关键字分布均匀的表，
    - 多于表长较大的顺序表，其平均性能比折半查找好
#### 9.1.3 静态树表的查找
#### 9.1.4 索引顺序表的查找
> 索引顺序表查找又称分块查找
- 要为表建立一个索引表
    - 即把其分为一个个子表，其包括关键字项和指针项(该子表的第一个记录)
- 其必须是“分块有序”
    - 即前一个子表的关键字及其它记录比后一个关键字要小
- 索引顺序表的查找分两步
    - 确定待查记录所在的块
    - 然后在块中顺序查找，若其有序则折半查找
- 分块查找的平均查找长度(成功)为${ASL}_{bs}= L_b+L_w$
    - $L_b$ 为查找索引表确定所在块的平均查找长度
    - $L_w$ 为在块中查找元素的平均查找长度
    - 用顺序查找确定所在的块，则分块查找的平均查找长度$${ASL}_{bs}= L_b+L_w = 1/b\sum_{j=1}^bj+1/s\sum_{i=1}^si=(b+1)/2+(s+1)/2$$
    - 当 s 取 $\sqrt{n}$ 时，${ASL}_{bs} $ 取最小 $ \sqrt{n}+1$
    - 用折半查找确定所在的块，则分块查找的平均查找长度$${ASL}_{bs} \approx log_2(n/s+1)+s/2$$
### 9.2 动态查找表
#### 9.2.1 二叉排序树和平衡二叉树
> 二叉排序树 (Binary Sort Tree) 或者是一颗空树；或者是具有下列性质的二叉树

    若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
    若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
    它的左右子树也分别为二叉排序树
- 二叉排序树查找
    - 首先将给定值和根结点的关键字比较，若相等，则查找成功，
    - 否则将依据给定值和根结点的关键字之间的大小关系，分别在左树或右树上继续进行查找
- 二叉排序树的存储结构
    - 二叉链表
- 二叉排序树的插入和删除
    - 二叉排序树是一个动态树表，故其可以不是一次生成的
    - 可以在查找的过程中，当树中不存在关键字等于给定值的结点时进行插入
    - 新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左或右孩子结点
        - 好处 
            - 不必移动其他结点，仅需改动某个结点的指针由空变为非空，
            - 拥有类似于折半查找的特点，但有链表作存储结构
    - 二叉排序树是由中序遍历生成的
- 二叉排序树的删除
    - 删除树上的一个结点相当于删去有序序列的一个记录，只要在删除某个结点之后仍保持二叉排序树的特性
    - 设在二叉排序树上被删结点为 *p，其双亲结点为 *f，设其为左孩子
    - 若 *p 结点为叶子结点，即 ${p_l}$ 和 ${p_r}$ 均为空树。由于删除叶子结点不被破坏整颗树的结构，则只需修改其双亲结点的指针即可
    - 若 *p 结点只有左子树  ${p_l}$ ，或右子树 ${p_r}$ 此时只要令 ${p_l}$ 或 ${p_r}$ 直接成为其双亲结点 * f 的左子树即可，这个操作不破坏二叉排序树的特性
    - 若 *p 结点的左子树和右子树均不为空时
        - 令 *p 的左子树为 *f 的左子树，从 *p 的左子树中找最大的值子树 *s，令 *p 的右子树成为 *s 的右子树
        - 令 *p 的直接前驱或直接后继代替 *p，然后再从二叉排序树中删除它的直接前驱或直接后继
- 二叉排序树的查找分析
    在二叉排序树中进行查找，若查找成功，则存在一条从根节到待查结点的查找路径；若查找失败，则走了一条从根结点到叶子结点的路径。于折半查找类似，和关键字比较的次数不超过树的深度。然而，在进行折半查找时，长度为 n 的表的判定树是唯一的，而含有 n 个结点的二叉排序树却不是唯一的，树的结构和形态依赖于结点插入的先后次序
> 平衡二叉树(Balanced Binary Tree 或 Height Binary Tree) 又称 AVL 树
- 它或者是一个空树
- 它或者是一个具有如下的性质的二叉树；它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差绝对值不超过 1，

    若将二叉树上的结点的平衡因子 BF(Balance Factor)定义为该结点的左子树的深度减右子树的深度，
    则平衡二叉树的上所有的结点的平衡因子只可能是 -1 0 或 1。只要其平衡因子的绝对值大于 1 则不
    为平衡二叉树
- 当其不为平衡二叉树就先找出其中最小不平衡子树
    - 最小不平衡子树是指离插入结点最近，且以平衡因子绝对值大于1的结点为根的子树。
    - 调整方法又4种
        - 单向右旋（LL顺时针）在结点 A 的左孩子的左子树上进行插入，插入使结点 A 失去平衡。A 插入前的平衡因子是 1 ，插入后平衡因子是 2，
            
            调整规则是进行一次顺时针旋转操作，即将 A 的左孩子 B 提升为新二叉树的根，原来的根 A 连同其右子树 A_R向右下旋转成为 B 的右子树，
            而原 B 的右子树 B_R 作为 A 的左子树
        - 单向左旋（RR逆时针）在结点 A 的右孩子的右子树上进行插入，插入使结点 A 失去平衡。A 插入前的平衡因子是 -1 ，插入后平衡因子是 -2，

            调整规则是进行一次逆时针旋转操作，即将 A 的右孩子 B 提升为新二叉树的根，原来的根 A 连同其左子树 A_L 向左下旋转成为 B 的右子树，
            而原 B 的左子树 B_L 作为 A 的右子树
        - LR（先逆后顺）在结点 A 的左孩子的右子树上插入结点，插入使结点 A 失去平衡。A 插入前的平衡因子是 1，插入后 A 的平衡因子是 2

            调整规则是先以 B 进行一次逆时针旋转(将以 B 为根的子树旋转以 C 为根)操作，再将 A 进行一次顺时针旋转，将整颗子树旋转为以 C 为根，
            旋转前 B 是 C 的左子树，A 是 C 的右子树；C 的右子树移动到 A 的左子树位置，C 的左子树移动到 B 的右子树位置
        - RL（先顺后逆）在结点 A 的右孩子的左子树上插入结点，插入使结点 A 失去平衡。A 插入前的平衡因子是 -1，插入后 A 的平衡因子是 -2

            调整规则是先以 B 进行一次顺时针旋转(将以 B 为根的子树旋转以 C 为根)操作，再将 A 进行一次逆时针旋转，将整颗子树旋转为以 C 为根，
            旋转前 B 是 C 的左子树，A 是 C 的右子树；C 的右子树移动到 B 的左子树位置，C 的左子树移动到 A 的右子树位置

###
###
###
###
###
>
>
>
>



