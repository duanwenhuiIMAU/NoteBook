# 数据结构
## 6 树与二叉树
### 6.1 树的定义和基本术语
>    树 是n（n >= 0）个结点的有限集 

>>   在任意一颗非空树中  有且仅有一个特定的称为根（Root）的结点

>>  当 n > 1 时，其余节点可分为 m ( m > 0 ) 个互不相交的有限集 T1， T2，... Tm, 其中每个集合本身又是一颗树， 并称为根结点的树；
    
    树的中心点
        n = 0 空树
        n = 1 根结点
        n >= 2 子树 互不相交 递归  层次
> 
***
    一颗树（ n >= 2 ）                        
                        A 
                    B   C    D
                  E  F  G  H I J  
                 K L       M
***
    如上图树是有 13 个结点的树，其中 A 是根，其余节点分成 3 个互不相交的子集：
    T1 = { B,E,F,K,L }, T2 = { C,G }, T3 = { D,H,I,J,M }; 
    T1,T2 和 T3 都是根 A 的子树，且本身也是一颗树。即 例如 T1, 其根为 B, 
    其余节点分成 2 个互不相交的子集： T11 = { E,K,L }, T12 = { F }; T1和T2 都是根 B 的子树。
    而 T11 中 E 是根，{ K },{ L } 是 E 的两棵互不相交的子树；其本身又是只有一个根结点的树。
> 树的节点 包含一个数据元素及若干指向其子树的分支。

> 结点的度（Degree）结点拥有的子树数。

> 叶子（Leaf）又称 终端结点 是度为 0 的结点。

> 分支结点 又称 非终端结点 是度不为 0 的结点。

> 树的度 是 树内各结点的度的最大值。

> 孩子（Child）是结点的子树的根。该结点是孩子的双亲（Parent）。同一双亲的孩子互为兄弟（Sibling）。
    
        如 上图 B 为 A 的子树 T1 的根，则 D 是 A 的孩子，而 A 是 D 的双亲。 B, C 和 D 互为兄弟

> 结点的祖先 是从根到该结点所经过分支上的所有结点 如上图 M 的祖先为 A D H 。

> 结点的子孙 以某一节点为根的子树中的任一结点。 如上图 B 的子孙为 E K L。

> 节点的层次（Level）从根结点开始定义，根为第一层，根的孩子为第二层。若某结点在第 L 层，则其子树的根就在第 L + 1 层。其双亲在同一层的结点互为堂兄弟。树中的结点的最大层次为树的深度（Depth） 或高度。
    
    如上图 结点 G 与 E, F, H, I, J 互为堂兄弟。树的深度为 4。
> 如果将树的结点的各子树的看成从左至右是次序的即不能互换的则为有序树。否则为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。

> 森林（Forest）是 m （ m >= 0 ） 颗互不相交的树的集合。
#### 树的计算
    1. 一颗有 n 个结点的树，它的所有结点的度数之和为 n-1
        证明 ： 
                当 n = 0 ，无结点
                当 n = 1 ，一个结点， 一个度
                当 n >= 2  
                第一层次的根节点只有一个方向的关系 即不是任何结点的孩子 并且其度不为 0  可以理解为第一层次的根节点不被任何一层结点所拥有 
                故计算时需要减去第一层次的根节点的一个度 即 n-1 
    2. 在一颗度为 4 的树 T 中，如果有 20 个度为4的结点，10 个度为 3 的的结点，1 个度为 2 的结点，10 个度为 1 的结点， 则树 T 的叶结点数为  
        由 1. 知 
              总结点数 = 所有结点的度和 + 1
            其他概念 根与子树的连线叫边  则结点数 = 边 - 1
            则总结点数 = 20 * n4 + 10 * n3 + n2 + 10 * n1 + n0 * 0 + 1 = 20 * 4 + 10 * 3 + 2 + 10 * 1 + 1 = 123 = n1 + n2 + n3 + n4 + n0
            n0 = 总结点数 -（ n1 + n2 + n3 + n4 ）= 123 - 20 - 10 - 1 -10 = 8
    3. 对于一颗具有 n 个结点 度为 4 的树的高度至多是 n-3;
    4. 对于一颗度为 4 高为 h 的树 其结点至少是 h+3;
         如图
              A
              B
              C
              D E F H
### 6.2 二叉树
#### 6.2.1 二叉树的定义   
    最多 2 个结点 有序
    二叉树的五种基本形态  空树 根树 根树加左 根树加右 根树加左右
#### 6.2.2 二叉树的性质
    1. 在二叉树的第 i 层上至多有 2^(i-1) 个结点（i>=1）
    2. 深度为 k 的二叉树至多有 2^k-1 个结点（k>=1）
    3. 对于任何一颗二叉树 T，如果其终端结点数为 n0，度为 2 的结点数为 n2，则有 n0 = n2 + 1
    满二叉树是一颗深度为 k 且有 2^k-1 个结点的二叉树
    完全二叉树是深度为 k 的，有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 k 的
    满二叉树中编号（至上而下，从左到右）从 1 至 n 的结点一一对应
    4. 具有 n 个结点的完全二叉树的深度为 log2/n（向下取整）+ 1
    5. 如果对一颗有 n 个结点的完全二叉树（其深度为 log2/n（向下取整）+ 1）的结点按层序编号（至上而下，从左到右），
    则对于任一结点 i （1 <= i <= n）,有
        （1）如果 i = 1，则结点 i 是二叉树的根，无双亲；如果 i > 1,则其双亲parent是结点 i/2（向下取整）
        （2）如果 2i > n，则结点 i 无左孩子（即结点 i 为叶子结点） ；否则其左孩子Lchild（i）是结点 2i
        （3）如果 2i+1 > n，则结点 i 无右孩子（即结点 i 为叶子结点） ；否则其右孩子Rchild（i）是结点 2i+1  如下图
                    i/2（向下取整）
                i            i+1
            2i    2i+1   2i+2   2i+3
#### 6.2.3 二叉树的储存结构
    1. 顺序储存结构  
        由性质 2 知最坏的情况下，一个深度为 k 且 只有 k 个结点的单支数 却需要长度为 2^k-1 的一维数组
        其位置表示其关系  性质 5
    2. 链式储存结构 
        双亲表示
        左右孩子表示 二叉链表 
        左右孩子加双亲表示 三叉链表
        左子右兄表示
        线索链表 = 左右孩子表示 + 标识域（标识其指针为孩子还是直接前驱（左指针域）和直接后继（右指针域））
#### 6.2.4 二叉树的计算  
    前序遍历 根左右
    中序遍历 左根右
    后序遍历 左右根
    知中序和另一序求二叉树de方法
        1.前序第一个为根结点 后序的最后一个为根结点
        2.中序中对应的结点两侧分左右数
        3.递归
#### 6.2.5 二叉树与森林的转换
***
    左子右兄表示
              森林               对应的二叉树
         A      E     G                A
      B  C  D   F    H  I          B       E
                        J           C    F   G
                                     D      H
                                             I
                                            J
***                                   
#### 6.2.6 赫夫曼树（最优二叉树）
    //这一部分还有例题
    赫夫曼树是带权路径长度（WPL）最小的二叉树
    小的在下 大的在上 两小相加 小于其他 则为空一
## 7 图
### 7.1 图的定义和术语
> 顶点（Vertex）图中数据元素 

> V是顶点的有穷非空集合 

> VR是两个顶点之间的关系的集合 

> 若 <v,w> 属于 VR 则 <v,w> 表示从 v 到 w 的一条弧（Arc），v 为弧尾（Tail）或初始点（Initial node），
w 为弧头（Head）或终端点（Terminal node），这样的图为有向图（Digraph）

> 若 <v,w> 属于 VR 必有 <w,v> 属于 VR 这样的图叫无向图（Undigraph） 无向图的邻接矩阵对称 
    以无序对（v,w）代替这两个有序对，表示 v 和 w 之间的一条边（Edge）

    设 顶点数为 n，边或弧数为 e，
    无向图 0 <= e <= 1/2 n (n-1) 当 e = 1/2 n (n-1) 为完全图
    有向图 0 <= e <= n (n-1) 当 e =  n (n-1) 为有向完全图
    稀疏图 e < n log 2\n 反之，稠密图

> 对于无向图 边连两点，则两点互为邻接点（Adjacent）其边依附于两点，或其边于两点相关联。 
    
     顶点 v 的度（Degree）是和 v 相关的边的数目，记为 TD（v）。

>   对于有向图A 如果弧 <v,w> 属于 A，则称顶点 v 邻接到 w ，顶点 w 邻接自 v ，弧 <v,w>于两点相关联。

    以顶点 v 为头的弧数目称为 v 的入度（Indegree），记为ID(v)。
    以顶点 v 为尾的弧数目称为 v 的出度（Outdegree），记为OD(v)。（树是只有出度无入度）
    顶点 v 的度（Degree）TD(v)= ID(v) + OD(v)。
>  无向图中从顶点 v 到 w 的路径（Path）是一个顶点序列，如果是有向图路径有向。路径长度是路径上边或弧的数目。

    第一和最后一个顶点相同的路径叫 回路 或 环（Cycle）。
    顶点不重复叫简单路径。顶点不重复的环叫简单环。
    无向图 如果从顶点 v 到 w 有路径，则称 v 和 w 是连通的。
    任何两顶点都连通是连通图（Cennected Graph）。
    连通分量（Connected Component）是无向图中极大连通子图。
    在有向图叫 强连通图 强连通分量 生成树（极小连通子图）（有无向图均有这个概念）。
    对于非连通图，由各点连通分量的生成树构成的集合，称为该非连通图的生成森林。
### 7.2 图的储存结构

#### 7.2.1 数组表示法（邻接矩阵）
> 用两个数组分别储存数组元素（顶点）的信息和数据元素之间的关系（边或弧）的信息。
    有向图的非对称，无向图的对称
    // -------图的数组表示法（邻接矩阵）---------
        
    #define INFINITY INT_MAX                  // 最大值
    #define MAX_VERTEX_NUM 20                 // 最大顶点个数
    typedef enum {DG,DN,UDG,UDG} GraphKind;   // 有向图，有向网，无向图，无向网
    typedef struct ArcCell{
        VRType adj;         // VRType是顶点关系类型。
                            //对无权图，用 1 或 0 表示表示相邻否
                            //对带权图，则为权值类型
        InfoType *info;     //该弧相关的指针
    };
    typedef struct Graph{
       VertexType vexs[MAX_VERTEX_NUM]; //顶点数量
       AdjMatrix arcs;                  //邻接矩阵
       int vexnum, arcnum;              //图的当前顶点数和弧数
       GraphKind kind;                  //图的种类
    };

#### 7.2.2 邻接表
    对图的每个顶点建立一个单链表，第 i 个单链表中的结点表示依附于顶点 vi 的边。
        每个结点由 3 个域组成，其中邻接点域（adjvex）指示与顶点 vi邻接的点在图位置，链域（nextarc）指示下一个边或弧的结点，数据域储存和边或弧相关的信息，如权值。
    // -------图的邻接表---------
    #define MAX_VERTEX_NUM 20                 // 最大顶点个数
    typedef struct ArcNode{
       int adjvex;                      //该弧所指向的顶点的位置
       struct ArcNode *nexttarc;        //指向下一条弧的指针
       InfoType *info;                  //该弧相关的指针
    };
    typedef struct VNode{
       VertexType data;                 // 顶点信息          
       ArcNode *firstarc;               // 指向第一条依附该点的弧的指针
    }VNode,AdjList[MAX_VERTEX_NUM];
    typedef struct ALGraph{
      
    };
###
###
###
###
###
###
###
###
###
###
###
###
###
###
###
###
###
>
>
>
>



